import React, { useEffect, useReducer, useCallback, useState, } from 'react';
import { DragDropContext, Droppable } from 'react-beautiful-dnd';
import { usePreferences } from '../../../utilities/Preferences';
import withCondition from '../../withCondition';
import Button from '../../../elements/Button';
import reducer from '../rowReducer';
import { useDocumentInfo } from '../../../utilities/DocumentInfo';
import { useForm } from '../../Form/context';
import buildStateFromSchema from '../../Form/buildStateFromSchema';
import DraggableSection from '../../DraggableSection';
import Error from '../../Error';
import useFieldType from '../../useFieldType';
import Popup from '../../../elements/Popup';
import BlockSelector from './BlockSelector';
import { blocks as blocksValidator } from '../../../../../fields/validations';
import Banner from '../../../elements/Banner';
import FieldDescription from '../../FieldDescription';
import './index.scss';
const baseClass = 'field-type blocks';
const labelDefaults = {
    singular: 'Block',
    plural: 'Blocks',
};
const Blocks = (props) => {
    const { label, name, path: pathFromProps, blocks, labels = labelDefaults, fieldTypes, maxRows, minRows, required, validate = blocksValidator, permissions, admin: { readOnly, description, condition, }, } = props;
    const path = pathFromProps || name;
    const { preferencesKey } = useDocumentInfo();
    const { getPreference, setPreference } = usePreferences();
    const [rows, dispatchRows] = useReducer(reducer, []);
    const formContext = useForm();
    const { dispatchFields } = formContext;
    const memoizedValidate = useCallback((value) => {
        const validationResult = validate(value, {
            minRows, maxRows, labels, blocks, required,
        });
        return validationResult;
    }, [validate, maxRows, minRows, labels, blocks, required]);
    const [disableFormData, setDisableFormData] = useState(false);
    const { showError, errorMessage, value, setValue, } = useFieldType({
        path,
        validate: memoizedValidate,
        disableFormData,
        ignoreWhileFlattening: true,
        condition,
    });
    const addRow = useCallback(async (rowIndex, blockType) => {
        const block = blocks.find((potentialBlock) => potentialBlock.slug === blockType);
        const subFieldState = await buildStateFromSchema(block.fields);
        dispatchFields({ type: 'ADD_ROW', rowIndex, subFieldState, path, blockType });
        dispatchRows({ type: 'ADD', rowIndex, blockType });
        setValue(value + 1);
    }, [path, setValue, value, blocks, dispatchFields]);
    const removeRow = useCallback((rowIndex) => {
        dispatchRows({ type: 'REMOVE', rowIndex });
        dispatchFields({ type: 'REMOVE_ROW', rowIndex, path });
        setValue(value - 1);
    }, [path, setValue, value, dispatchFields]);
    const moveRow = useCallback((moveFromIndex, moveToIndex) => {
        dispatchRows({ type: 'MOVE', moveFromIndex, moveToIndex });
        dispatchFields({ type: 'MOVE_ROW', moveFromIndex, moveToIndex, path });
    }, [dispatchRows, dispatchFields, path]);
    const setCollapse = useCallback(async (id, collapsed) => {
        var _a, _b, _c;
        dispatchRows({ type: 'SET_COLLAPSE', id, collapsed });
        if (preferencesKey) {
            const preferences = await getPreference(preferencesKey);
            const preferencesToSet = preferences || { fields: {} };
            let newCollapsedState = ((_b = (_a = preferencesToSet === null || preferencesToSet === void 0 ? void 0 : preferencesToSet.fields) === null || _a === void 0 ? void 0 : _a[path]) === null || _b === void 0 ? void 0 : _b.collapsed.filter((filterID) => (rows.find((row) => row.id === filterID))))
                || [];
            if (!collapsed) {
                newCollapsedState = newCollapsedState.filter((existingID) => existingID !== id);
            }
            else {
                newCollapsedState.push(id);
            }
            setPreference(preferencesKey, {
                ...preferencesToSet,
                fields: {
                    ...(preferencesToSet === null || preferencesToSet === void 0 ? void 0 : preferencesToSet.fields) || {},
                    [path]: {
                        ...(_c = preferencesToSet === null || preferencesToSet === void 0 ? void 0 : preferencesToSet.fields) === null || _c === void 0 ? void 0 : _c[path],
                        collapsed: newCollapsedState,
                    },
                },
            });
        }
    }, [preferencesKey, getPreference, path, setPreference, rows]);
    const onDragEnd = useCallback((result) => {
        if (!result.destination)
            return;
        const sourceIndex = result.source.index;
        const destinationIndex = result.destination.index;
        moveRow(sourceIndex, destinationIndex);
    }, [moveRow]);
    useEffect(() => {
        const fetchPreferences = async () => {
            var _a, _b;
            const preferences = preferencesKey ? await getPreference(preferencesKey) : undefined;
            const data = formContext.getDataByPath(path);
            dispatchRows({ type: 'SET_ALL', data: data || [], collapsedState: (_b = (_a = preferences === null || preferences === void 0 ? void 0 : preferences.fields) === null || _a === void 0 ? void 0 : _a[path]) === null || _b === void 0 ? void 0 : _b.collapsed });
        };
        fetchPreferences();
    }, [formContext, path, preferencesKey, getPreference]);
    useEffect(() => {
        setValue((rows === null || rows === void 0 ? void 0 : rows.length) || 0);
        if ((rows === null || rows === void 0 ? void 0 : rows.length) === 0) {
            setDisableFormData(false);
        }
        else {
            setDisableFormData(true);
        }
    }, [rows, setValue]);
    return (React.createElement(RenderBlocks, { onDragEnd: onDragEnd, label: label, showError: showError, errorMessage: errorMessage, rows: rows, labels: labels, addRow: addRow, removeRow: removeRow, moveRow: moveRow, path: path, name: name, fieldTypes: fieldTypes, setCollapse: setCollapse, permissions: permissions, value: value, blocks: blocks, readOnly: readOnly, minRows: minRows, maxRows: maxRows, required: required, description: description }));
};
const RenderBlocks = React.memo((props) => {
    const { onDragEnd, label, showError, errorMessage, rows, labels, addRow, removeRow, moveRow, path, fieldTypes, permissions, value, setCollapse, blocks, readOnly, minRows, maxRows, required, description, } = props;
    const hasMaxRows = maxRows && rows.length >= maxRows;
    return (React.createElement(DragDropContext, { onDragEnd: onDragEnd },
        React.createElement("div", { className: baseClass },
            React.createElement("div", { className: `${baseClass}__error-wrap` },
                React.createElement(Error, { showError: showError, message: errorMessage })),
            React.createElement("header", { className: `${baseClass}__header` },
                React.createElement("h3", null, label),
                React.createElement(FieldDescription, { value: value, description: description })),
            React.createElement(Droppable, { droppableId: "blocks-drop", isDropDisabled: readOnly }, (provided) => (React.createElement("div", { ref: provided.innerRef, ...provided.droppableProps },
                rows.length > 0 && rows.map((row, i) => {
                    var _a;
                    const { blockType } = row;
                    const blockToRender = blocks.find((block) => block.slug === blockType);
                    if (blockToRender) {
                        return (React.createElement(DraggableSection, { readOnly: readOnly, key: row.id, id: row.id, blockType: "blocks", blocks: blocks, label: (_a = blockToRender === null || blockToRender === void 0 ? void 0 : blockToRender.labels) === null || _a === void 0 ? void 0 : _a.singular, isCollapsed: row.collapsed, rowCount: rows.length, rowIndex: i, addRow: addRow, removeRow: removeRow, moveRow: moveRow, setRowCollapse: setCollapse, parentPath: path, fieldTypes: fieldTypes, permissions: permissions, hasMaxRows: hasMaxRows, fieldSchema: [
                                ...blockToRender.fields,
                            ] }));
                    }
                    return null;
                }),
                (rows.length < minRows || (required && rows.length === 0)) && (React.createElement(Banner, { type: "error" },
                    "This field requires at least",
                    ' ',
                    `${minRows || 1} ${minRows === 1 || typeof minRows === 'undefined' ? labels.singular : labels.plural}`)),
                (rows.length === 0 && readOnly) && (React.createElement(Banner, null,
                    "This field has no",
                    ' ',
                    labels.plural,
                    ".")),
                provided.placeholder))),
            (!readOnly && (rows.length < maxRows || maxRows === undefined)) && (React.createElement("div", { className: `${baseClass}__add-button-wrap` },
                React.createElement(Popup, { buttonType: "custom", size: "large", horizontalAlign: "left", button: (React.createElement(Button, { buttonStyle: "icon-label", icon: "plus", iconPosition: "left", iconStyle: "with-border" }, `Add ${labels.singular}`)), render: ({ close }) => (React.createElement(BlockSelector, { blocks: blocks, addRow: addRow, addRowIndex: value, close: close })) }))))));
});
export default withCondition(Blocks);
