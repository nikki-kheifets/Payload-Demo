"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/* eslint-disable no-await-in-loop */
/* eslint-disable no-restricted-syntax */
const mongoose_1 = __importDefault(require("mongoose"));
const validOperators = ['like', 'in', 'all', 'not_in', 'greater_than_equal', 'greater_than', 'less_than_equal', 'less_than', 'not_equals', 'equals', 'exists'];
function addSearchParam(key, value, searchParams) {
    return {
        ...searchParams,
        [key]: value,
    };
}
function convertArrayFromCommaDelineated(input) {
    if (Array.isArray(input))
        return input;
    if (input.indexOf(',') > -1) {
        return input.split(',');
    }
    return [input];
}
class ParamParser {
    constructor(model, rawParams, locale) {
        this.parse = this.parse.bind(this);
        this.model = model;
        this.rawParams = rawParams;
        this.locale = locale;
        this.query = {
            searchParams: {},
            sort: false,
        };
    }
    getLocalizedKey(key, schemaObject) {
        return `${key}${(schemaObject && schemaObject.localized) ? `.${this.locale}` : ''}`;
    }
    // Entry point to the ParamParser class
    async parse() {
        if (typeof this.rawParams === 'object') {
            for (const key of Object.keys(this.rawParams)) {
                if (key === 'where') {
                    this.query.searchParams = await this.parsePathOrRelation(this.rawParams.where);
                }
                else if (key === 'sort') {
                    this.query.sort = this.rawParams[key];
                }
            }
            return this.query;
        }
        return {};
    }
    async parsePathOrRelation(object) {
        let result = {};
        // We need to determine if the whereKey is an AND, OR, or a schema path
        for (const relationOrPath of Object.keys(object)) {
            if (relationOrPath.toLowerCase() === 'and') {
                const andConditions = object[relationOrPath];
                const builtAndConditions = await this.buildAndOrConditions(andConditions);
                if (builtAndConditions.length > 0)
                    result.$and = builtAndConditions;
            }
            else if (relationOrPath.toLowerCase() === 'or' && Array.isArray(object[relationOrPath])) {
                const orConditions = object[relationOrPath];
                const builtOrConditions = await this.buildAndOrConditions(orConditions);
                if (builtOrConditions.length > 0)
                    result.$or = builtOrConditions;
            }
            else {
                // It's a path - and there can be multiple comparisons on a single path.
                // For example - title like 'test' and title not equal to 'tester'
                // So we need to loop on keys again here to handle each operator independently
                const pathOperators = object[relationOrPath];
                if (typeof pathOperators === 'object') {
                    for (const operator of Object.keys(pathOperators)) {
                        if (validOperators.includes(operator)) {
                            const searchParam = await this.buildSearchParam(this.model.schema, relationOrPath, pathOperators[operator], operator);
                            if (Array.isArray(searchParam)) {
                                const [key, value] = searchParam;
                                result = addSearchParam(key, value, result);
                            }
                        }
                    }
                }
            }
        }
        return result;
    }
    async buildAndOrConditions(conditions) {
        const completedConditions = [];
        // Loop over all AND / OR operations and add them to the AND / OR query param
        // Operations should come through as an array
        for (const condition of conditions) {
            // If the operation is properly formatted as an object
            if (typeof condition === 'object') {
                const result = await this.parsePathOrRelation(condition);
                completedConditions.push(result);
            }
        }
        return completedConditions;
    }
    // Checks to see
    async buildSearchParam(schema, key, val, operator) {
        let schemaObject = schema.obj[key];
        const sanitizedKey = key.replace(/__/gi, '.');
        let localizedKey = this.getLocalizedKey(sanitizedKey, schemaObject);
        if (key === '_id' || key === 'id') {
            localizedKey = '_id';
            if (!mongoose_1.default.Types.ObjectId.isValid(val)) {
                return null;
            }
        }
        if (key.includes('.') || key.includes('__')) {
            const paths = key.split('.');
            schemaObject = schema.obj[paths[0]];
            const localizedPath = this.getLocalizedKey(paths[0], schemaObject);
            const path = schema.paths[localizedPath];
            // If the schema object has a dot, split on the dot
            // Check the path of the first index of the newly split array
            // If it's an array OR an ObjectID, we need to recurse
            if (path) {
                // If the path is an ObjectId with a direct ref,
                // Grab it
                let { ref } = path.options;
                // If the path is an Array, grab the ref of the first index type
                if (path.instance === 'Array') {
                    ref = path.options && path.options.type && path.options.type[0].ref;
                }
                // //////////////////////////////////////////////////////////////////////////
                // TODO:
                //
                // Need to handle relationships that have more than one type.
                // Right now, this code only handles one ref. But there could be a
                // refPath as well, which could allow for a relation to multiple types.
                // In that case, we would need to get the allowed referenced models
                // and run the subModel query on each - building up a list of $in IDs.
                // //////////////////////////////////////////////////////////////////////////
                if (ref) {
                    const subModel = mongoose_1.default.model(ref);
                    let subQuery = {};
                    const localizedSubKey = this.getLocalizedKey(paths[1], subModel.schema.obj[paths[1]]);
                    const [searchParamKey, searchParamValue] = await this.buildSearchParam(subModel.schema, localizedSubKey, val, operator);
                    subQuery = addSearchParam(searchParamKey, searchParamValue, subQuery);
                    const matchingSubDocuments = await subModel.find(subQuery);
                    return [localizedPath, {
                            $in: matchingSubDocuments.map((subDoc) => subDoc.id),
                        }];
                }
            }
        }
        let formattedValue = val;
        const schemaObjectType = (schemaObject === null || schemaObject === void 0 ? void 0 : schemaObject.localized) ? schemaObject === null || schemaObject === void 0 ? void 0 : schemaObject.type[this.locale].type : schemaObject === null || schemaObject === void 0 ? void 0 : schemaObject.type;
        if (schemaObject && schemaObjectType === Boolean && typeof val === 'string') {
            if (val.toLowerCase() === 'true')
                formattedValue = true;
            if (val.toLowerCase() === 'false')
                formattedValue = false;
        }
        if (schemaObject && schemaObjectType === Number && typeof val === 'string') {
            formattedValue = Number(val);
        }
        if (schemaObject && schemaObject.ref && val === 'null') {
            formattedValue = null;
        }
        if (operator && validOperators.includes(operator)) {
            switch (operator) {
                case 'greater_than_equal':
                    formattedValue = { $gte: formattedValue };
                    break;
                case 'less_than_equal':
                    formattedValue = { $lte: formattedValue };
                    break;
                case 'less_than':
                    formattedValue = { $lt: formattedValue };
                    break;
                case 'greater_than':
                    formattedValue = { $gt: formattedValue };
                    break;
                case 'in':
                case 'all':
                    formattedValue = { [`$${operator}`]: convertArrayFromCommaDelineated(formattedValue) };
                    break;
                case 'not_in':
                    formattedValue = { $nin: convertArrayFromCommaDelineated(formattedValue) };
                    break;
                case 'not_equals':
                    formattedValue = { $ne: formattedValue };
                    break;
                case 'like':
                    if (localizedKey !== '_id') {
                        formattedValue = { $regex: formattedValue, $options: '-i' };
                    }
                    break;
                case 'exists':
                    formattedValue = { $exists: (formattedValue === 'true' || formattedValue === true) };
                    break;
                default:
                    break;
            }
        }
        return [localizedKey, formattedValue];
    }
}
// This plugin asynchronously builds a list of Mongoose query constraints
// which can then be used in subsequent Mongoose queries.
function buildQueryPlugin(schema) {
    const modifiedSchema = schema;
    async function buildQuery(rawParams, locale) {
        const paramParser = new ParamParser(this, rawParams, locale);
        const params = await paramParser.parse();
        return params.searchParams;
    }
    modifiedSchema.statics.buildQuery = buildQuery;
}
exports.default = buildQueryPlugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVpbGRRdWVyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tb25nb29zZS9idWlsZFF1ZXJ5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEscUNBQXFDO0FBQ3JDLHlDQUF5QztBQUN6Qyx3REFBaUQ7QUFFakQsTUFBTSxjQUFjLEdBQUcsQ0FBQyxNQUFNLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsY0FBYyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQy9KLFNBQVMsY0FBYyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsWUFBWTtJQUM5QyxPQUFPO1FBQ0wsR0FBRyxZQUFZO1FBQ2YsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLO0tBQ2IsQ0FBQztBQUNKLENBQUM7QUFDRCxTQUFTLCtCQUErQixDQUFDLEtBQUs7SUFDNUMsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQztRQUFFLE9BQU8sS0FBSyxDQUFDO0lBQ3ZDLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUMzQixPQUFPLEtBQUssQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDekI7SUFDRCxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDakIsQ0FBQztBQVdELE1BQU0sV0FBVztJQWNmLFlBQVksS0FBSyxFQUFFLFNBQVMsRUFBRSxNQUFjO1FBQzFDLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDbkMsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7UUFDM0IsSUFBSSxDQUFDLE1BQU0sR0FBRyxNQUFNLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRztZQUNYLFlBQVksRUFBRSxFQUFFO1lBQ2hCLElBQUksRUFBRSxLQUFLO1NBQ1osQ0FBQztJQUNKLENBQUM7SUFFRCxlQUFlLENBQUMsR0FBVyxFQUFFLFlBQVk7UUFDdkMsT0FBTyxHQUFHLEdBQUcsR0FBRyxDQUFDLFlBQVksSUFBSSxZQUFZLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUN0RixDQUFDO0lBRUQsdUNBQXVDO0lBRXZDLEtBQUssQ0FBQyxLQUFLO1FBQ1QsSUFBSSxPQUFPLElBQUksQ0FBQyxTQUFTLEtBQUssUUFBUSxFQUFFO1lBQ3RDLEtBQUssTUFBTSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7Z0JBQzdDLElBQUksR0FBRyxLQUFLLE9BQU8sRUFBRTtvQkFDbkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDaEY7cUJBQU0sSUFBSSxHQUFHLEtBQUssTUFBTSxFQUFFO29CQUN6QixJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2lCQUN2QzthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1NBQ25CO1FBQ0QsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsS0FBSyxDQUFDLG1CQUFtQixDQUFDLE1BQU07UUFDOUIsSUFBSSxNQUFNLEdBQUcsRUFBc0IsQ0FBQztRQUNwQyx1RUFBdUU7UUFDdkUsS0FBSyxNQUFNLGNBQWMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ2hELElBQUksY0FBYyxDQUFDLFdBQVcsRUFBRSxLQUFLLEtBQUssRUFBRTtnQkFDMUMsTUFBTSxhQUFhLEdBQUcsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDO2dCQUM3QyxNQUFNLGtCQUFrQixHQUFHLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLGFBQWEsQ0FBQyxDQUFDO2dCQUMxRSxJQUFJLGtCQUFrQixDQUFDLE1BQU0sR0FBRyxDQUFDO29CQUFFLE1BQU0sQ0FBQyxJQUFJLEdBQUcsa0JBQWtCLENBQUM7YUFDckU7aUJBQU0sSUFBSSxjQUFjLENBQUMsV0FBVyxFQUFFLEtBQUssSUFBSSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDLEVBQUU7Z0JBQ3pGLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDNUMsTUFBTSxpQkFBaUIsR0FBRyxNQUFNLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxZQUFZLENBQUMsQ0FBQztnQkFDeEUsSUFBSSxpQkFBaUIsQ0FBQyxNQUFNLEdBQUcsQ0FBQztvQkFBRSxNQUFNLENBQUMsR0FBRyxHQUFHLGlCQUFpQixDQUFDO2FBQ2xFO2lCQUFNO2dCQUNMLHdFQUF3RTtnQkFDeEUsa0VBQWtFO2dCQUNsRSw4RUFBOEU7Z0JBQzlFLE1BQU0sYUFBYSxHQUFHLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQztnQkFDN0MsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7b0JBQ3JDLEtBQUssTUFBTSxRQUFRLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsRUFBRTt3QkFDakQsSUFBSSxjQUFjLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFOzRCQUNyQyxNQUFNLFdBQVcsR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxjQUFjLEVBQUUsYUFBYSxDQUFDLFFBQVEsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxDQUFDOzRCQUN0SCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0NBQzlCLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLEdBQUcsV0FBVyxDQUFDO2dDQUNqQyxNQUFNLEdBQUcsY0FBYyxDQUFDLEdBQUcsRUFBRSxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7NkJBQzdDO3lCQUNGO3FCQUNGO2lCQUNGO2FBQ0Y7U0FDRjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7SUFFRCxLQUFLLENBQUMsb0JBQW9CLENBQUMsVUFBVTtRQUNuQyxNQUFNLG1CQUFtQixHQUFHLEVBQUUsQ0FBQztRQUMvQiw2RUFBNkU7UUFDN0UsNkNBQTZDO1FBQzdDLEtBQUssTUFBTSxTQUFTLElBQUksVUFBVSxFQUFFO1lBQ2xDLHNEQUFzRDtZQUN0RCxJQUFJLE9BQU8sU0FBUyxLQUFLLFFBQVEsRUFBRTtnQkFDakMsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsbUJBQW1CLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3pELG1CQUFtQixDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUNsQztTQUNGO1FBQ0QsT0FBTyxtQkFBbUIsQ0FBQztJQUM3QixDQUFDO0lBRUQsZ0JBQWdCO0lBQ2hCLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLEVBQUUsR0FBRyxFQUFFLEdBQUcsRUFBRSxRQUFRO1FBQy9DLElBQUksWUFBWSxHQUFHLE1BQU0sQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDbkMsTUFBTSxZQUFZLEdBQUcsR0FBRyxDQUFDLE9BQU8sQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7UUFDOUMsSUFBSSxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDcEUsSUFBSSxHQUFHLEtBQUssS0FBSyxJQUFJLEdBQUcsS0FBSyxJQUFJLEVBQUU7WUFDakMsWUFBWSxHQUFHLEtBQUssQ0FBQztZQUNyQixJQUFJLENBQUMsa0JBQVEsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtnQkFDekMsT0FBTyxJQUFJLENBQUM7YUFDYjtTQUNGO1FBQ0QsSUFBSSxHQUFHLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDM0MsTUFBTSxLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUM3QixZQUFZLEdBQUcsTUFBTSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUNwQyxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsQ0FBQztZQUNuRSxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1lBQ3pDLG1EQUFtRDtZQUNuRCw2REFBNkQ7WUFDN0Qsc0RBQXNEO1lBQ3RELElBQUksSUFBSSxFQUFFO2dCQUNSLGdEQUFnRDtnQkFDaEQsVUFBVTtnQkFDVixJQUFJLEVBQUUsR0FBRyxFQUFFLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztnQkFDM0IsZ0VBQWdFO2dCQUNoRSxJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssT0FBTyxFQUFFO29CQUM3QixHQUFHLEdBQUcsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7aUJBQ3JFO2dCQUNELDZFQUE2RTtnQkFDN0UsUUFBUTtnQkFDUixFQUFFO2dCQUNGLDZEQUE2RDtnQkFDN0Qsa0VBQWtFO2dCQUNsRSx1RUFBdUU7Z0JBQ3ZFLG1FQUFtRTtnQkFDbkUsc0VBQXNFO2dCQUN0RSw2RUFBNkU7Z0JBQzdFLElBQUksR0FBRyxFQUFFO29CQUNQLE1BQU0sUUFBUSxHQUFHLGtCQUFRLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO29CQUNyQyxJQUFJLFFBQVEsR0FBRyxFQUFFLENBQUM7b0JBQ2xCLE1BQU0sZUFBZSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ3RGLE1BQU0sQ0FBQyxjQUFjLEVBQUUsZ0JBQWdCLENBQUMsR0FBRyxNQUFNLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsTUFBTSxFQUFFLGVBQWUsRUFBRSxHQUFHLEVBQUUsUUFBUSxDQUFDLENBQUM7b0JBQ3hILFFBQVEsR0FBRyxjQUFjLENBQUMsY0FBYyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsQ0FBQyxDQUFDO29CQUN0RSxNQUFNLG9CQUFvQixHQUFHLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztvQkFDM0QsT0FBTyxDQUFDLGFBQWEsRUFBRTs0QkFDckIsR0FBRyxFQUFFLG9CQUFvQixDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQzt5QkFDckQsQ0FBQyxDQUFDO2lCQUNKO2FBQ0Y7U0FDRjtRQUNELElBQUksY0FBYyxHQUFHLEdBQUcsQ0FBQztRQUV6QixNQUFNLGdCQUFnQixHQUFHLENBQUEsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLFNBQVMsRUFBQyxDQUFDLENBQUMsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsWUFBWSxhQUFaLFlBQVksdUJBQVosWUFBWSxDQUFFLElBQUksQ0FBQztRQUU3RyxJQUFJLFlBQVksSUFBSSxnQkFBZ0IsS0FBSyxPQUFPLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQzNFLElBQUksR0FBRyxDQUFDLFdBQVcsRUFBRSxLQUFLLE1BQU07Z0JBQUUsY0FBYyxHQUFHLElBQUksQ0FBQztZQUN4RCxJQUFJLEdBQUcsQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPO2dCQUFFLGNBQWMsR0FBRyxLQUFLLENBQUM7U0FDM0Q7UUFFRCxJQUFJLFlBQVksSUFBSSxnQkFBZ0IsS0FBSyxNQUFNLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1lBQzFFLGNBQWMsR0FBRyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDOUI7UUFFRCxJQUFJLFlBQVksSUFBSSxZQUFZLENBQUMsR0FBRyxJQUFJLEdBQUcsS0FBSyxNQUFNLEVBQUU7WUFDdEQsY0FBYyxHQUFHLElBQUksQ0FBQztTQUN2QjtRQUVELElBQUksUUFBUSxJQUFJLGNBQWMsQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFDakQsUUFBUSxRQUFRLEVBQUU7Z0JBQ2hCLEtBQUssb0JBQW9CO29CQUN2QixjQUFjLEdBQUcsRUFBRSxJQUFJLEVBQUUsY0FBYyxFQUFFLENBQUM7b0JBQzFDLE1BQU07Z0JBQ1IsS0FBSyxpQkFBaUI7b0JBQ3BCLGNBQWMsR0FBRyxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUUsQ0FBQztvQkFDMUMsTUFBTTtnQkFDUixLQUFLLFdBQVc7b0JBQ2QsY0FBYyxHQUFHLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxDQUFDO29CQUN6QyxNQUFNO2dCQUNSLEtBQUssY0FBYztvQkFDakIsY0FBYyxHQUFHLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxDQUFDO29CQUN6QyxNQUFNO2dCQUNSLEtBQUssSUFBSSxDQUFDO2dCQUNWLEtBQUssS0FBSztvQkFDUixjQUFjLEdBQUcsRUFBRSxDQUFDLElBQUksUUFBUSxFQUFFLENBQUMsRUFBRSwrQkFBK0IsQ0FBQyxjQUFjLENBQUMsRUFBRSxDQUFDO29CQUN2RixNQUFNO2dCQUNSLEtBQUssUUFBUTtvQkFDWCxjQUFjLEdBQUcsRUFBRSxJQUFJLEVBQUUsK0JBQStCLENBQUMsY0FBYyxDQUFDLEVBQUUsQ0FBQztvQkFDM0UsTUFBTTtnQkFDUixLQUFLLFlBQVk7b0JBQ2YsY0FBYyxHQUFHLEVBQUUsR0FBRyxFQUFFLGNBQWMsRUFBRSxDQUFDO29CQUN6QyxNQUFNO2dCQUNSLEtBQUssTUFBTTtvQkFDVCxJQUFJLFlBQVksS0FBSyxLQUFLLEVBQUU7d0JBQzFCLGNBQWMsR0FBRyxFQUFFLE1BQU0sRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxDQUFDO3FCQUM3RDtvQkFDRCxNQUFNO2dCQUNSLEtBQUssUUFBUTtvQkFDWCxjQUFjLEdBQUcsRUFBRSxPQUFPLEVBQUUsQ0FBQyxjQUFjLEtBQUssTUFBTSxJQUFJLGNBQWMsS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDO29CQUNyRixNQUFNO2dCQUNSO29CQUNFLE1BQU07YUFDVDtTQUNGO1FBQ0QsT0FBTyxDQUFDLFlBQVksRUFBRSxjQUFjLENBQUMsQ0FBQztJQUN4QyxDQUFDO0NBQ0Y7QUFDRCx5RUFBeUU7QUFDekUseURBQXlEO0FBQ3pELFNBQVMsZ0JBQWdCLENBQUMsTUFBTTtJQUM5QixNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUM7SUFDOUIsS0FBSyxVQUFVLFVBQVUsQ0FBQyxTQUFTLEVBQUUsTUFBTTtRQUN6QyxNQUFNLFdBQVcsR0FBRyxJQUFJLFdBQVcsQ0FBQyxJQUFJLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1FBQzdELE1BQU0sTUFBTSxHQUFHLE1BQU0sV0FBVyxDQUFDLEtBQUssRUFBRSxDQUFDO1FBQ3pDLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQztJQUM3QixDQUFDO0lBQ0QsY0FBYyxDQUFDLE9BQU8sQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO0FBQ2pELENBQUM7QUFDRCxrQkFBZSxnQkFBZ0IsQ0FBQyJ9